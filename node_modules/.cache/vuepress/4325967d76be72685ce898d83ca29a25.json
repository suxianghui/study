{"remainingRequest":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!D:\\1\\实训一\\study\\study\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!D:\\1\\实训一\\study\\study\\lib\\webpack\\markdownLoader.js??ref--1-2!D:\\1\\实训一\\study\\study\\src\\zh\\chain\\README.md?vue&type=template&id=d9daf6ae&","dependencies":[{"path":"D:\\1\\实训一\\study\\study\\src\\zh\\chain\\README.md","mtime":1557200317053},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\lib\\webpack\\markdownLoader.js","mtime":1557200316988}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"content\" }, [\n    _vm._m(0),\n    _vm._v(\" \"),\n    _c(\"p\", [\n      _vm._v(\n        \"在使用 react 的过程中，我们绕不开渲染性能优化问题，因为默认情况下 react 组件的 shouldComponentUpdate 函数会一直返回 true，这回导致所有的组件都会进行耗时的虚拟 DOM 比较。在使用 redux 作为 react 的逻辑层框架时，我们可以使用经典的 PureComponent+ShallowCompare 的方式进行渲染性能优化\"\n      )\n    ]),\n    _vm._v(\" \"),\n    _c(\"p\", [_vm._v(\"https://foio.github.io/mobx-react/\")]),\n    _vm._v(\" \"),\n    _vm._m(1),\n    _vm._v(\" \"),\n    _vm._m(2),\n    _vm._v(\" \"),\n    _vm._m(3),\n    _vm._v(\" \"),\n    _vm._m(4),\n    _vm._v(\" \"),\n    _vm._m(5),\n    _vm._v(\" \"),\n    _vm._m(6),\n    _vm._v(\" \"),\n    _vm._m(7),\n    _vm._v(\" \"),\n    _vm._m(8),\n    _vm._v(\" \"),\n    _vm._m(9),\n    _vm._v(\" \"),\n    _vm._m(10),\n    _vm._v(\" \"),\n    _vm._m(11),\n    _vm._v(\" \"),\n    _vm._m(12),\n    _vm._v(\" \"),\n    _vm._m(13),\n    _vm._m(14),\n    _vm._v(\" \"),\n    _vm._m(15),\n    _vm._v(\" \"),\n    _vm._m(16),\n    _vm._v(\" \"),\n    _vm._m(17),\n    _vm._v(\" \"),\n    _vm._m(18),\n    _vm._v(\" \"),\n    _vm._m(19),\n    _vm._v(\" \"),\n    _vm._m(20),\n    _vm._v(\" \"),\n    _c(\"p\", [_vm._v(\"作为一个数据层框架，mobx 基于一个最简单的原则：\")]),\n    _vm._v(\" \"),\n    _vm._m(21),\n    _vm._v(\" \"),\n    _c(\"p\", [\n      _vm._v(\n        \"在使用 mobx 作为 react 的 store 时，我们该如何进行渲染性能优化呢？\\n通过分析源代码发现，在使用@observer 将 react 组件转换成一个监听者(Reactions)后，mobx 会为 react 组件提供一个精确的、细粒度的 shouldComponentUpdate 函数:\"\n      )\n    ]),\n    _vm._v(\" \"),\n    _vm._m(22),\n    _c(\"p\", [\n      _vm._v(\n        \"借助于 mobx 框架对 Observable 变量引用的跟踪和依赖收集，mobx 能够精确地得到 react 组件对 Observable 变量的依赖图谱，然后再用经典的 ShallowCompare 实现细粒度的 shouldComponentUpdate 函数，以达到 100%无浪费 render。这一切都是自动完成地，fantastic！使用 mobx 后，我们再也无需手动写 shouldComponentUpdate 函数了。\"\n      )\n    ]),\n    _vm._v(\" \"),\n    _vm._m(23),\n    _vm._v(\" \"),\n    _vm._m(24),\n    _vm._v(\" \"),\n    _vm._m(25),\n    _vm._v(\" \"),\n    _vm._m(26),\n    _vm._v(\" \"),\n    _vm._m(27),\n    _vm._v(\" \"),\n    _vm._m(28),\n    _vm._v(\" \"),\n    _vm._m(29),\n    _vm._v(\" \"),\n    _vm._m(30),\n    _vm._v(\" \"),\n    _vm._m(31),\n    _vm._v(\" \"),\n    _c(\"p\", [\n      _c(\n        \"a\",\n        {\n          attrs: {\n            href: \"https://github.com/semlinker/reactjs-interview-questions\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\"\n          }\n        },\n        [_vm._v(\"reactjs-interview-questions\"), _c(\"OutboundLink\")],\n        1\n      )\n    ])\n  ])\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h1\", { attrs: { id: \"react\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#react\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" React\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h2\", { attrs: { id: \"学习重点划分\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#学习重点划分\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" 学习重点划分\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h3\", { attrs: { id: \"jsx是什么\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#jsx是什么\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" jsx是什么?\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ul\", [\n      _c(\"li\", [_vm._v(\"React 使用 JSX 来替代常规的 JavaScript\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"JSX 是一个看起来很像 XML 的 JavaScript 语法扩展\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"我们不需要一定使用 JSX，但它有以下优点\")])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ol\", [\n      _c(\"li\", [\n        _c(\"blockquote\", [\n          _c(\"p\", [\n            _vm._v(\"JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化\")\n          ])\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _c(\"blockquote\", [\n          _c(\"p\", [_vm._v(\"它是类型安全的，在编译过程中就能发现错误\")])\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _c(\"blockquote\", [_c(\"p\", [_vm._v(\"使用 JSX 编写模板更加简单快速\")])])\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h3\", { attrs: { id: \"mvvm是什么？\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#mvvm是什么？\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" MVVM是什么？\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ol\", [\n      _c(\"li\", [_vm._v(\"MVVM是Model-View-ViewModel的简写\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"它本质上是MVC 的改进版\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\n          \"MVVM（Model-View-ViewModel）框架的由来是MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构框架\"\n        )\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h4\", { attrs: { id: \"mvvm优点\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#mvvm优点\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" MVVM优点\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ul\", [\n      _c(\"li\", [\n        _c(\"blockquote\", [\n          _c(\"p\", [\n            _vm._v(\n              \"MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点\"\n            )\n          ])\n        ])\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ol\", [\n      _c(\"li\", [\n        _c(\"strong\", [_vm._v(\"低耦合\")]),\n        _vm._v(\n          '：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的\"View\"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变'\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _c(\"strong\", [_vm._v(\"可重用性\")]),\n        _vm._v(\n          \"：你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _c(\"strong\", [_vm._v(\"独立开发\")]),\n        _vm._v(\n          \"：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _c(\"strong\", [_vm._v(\"可测试\")]),\n        _vm._v(\"：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写\")\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h3\", { attrs: { id: \"props\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#props\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" Props\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ul\", [\n      _c(\"li\", [\n        _c(\"blockquote\", [_c(\"p\", [_vm._v(\"和props相关\")])]),\n        _vm._v(\" \"),\n        _c(\"ul\", [\n          _c(\"li\", [_vm._v(\"只读，不准修改\")]),\n          _vm._v(\" \"),\n          _c(\"li\", [_vm._v(\"componentWillReceiveProps  / 生命周期\")]),\n          _vm._v(\" \"),\n          _c(\"li\", [_vm._v(\"propTypes\")]),\n          _vm._v(\" \"),\n          _c(\"li\", [_vm._v(\"defaultProps\")]),\n          _vm._v(\" \"),\n          _c(\"li\", [_vm._v(\"children\")])\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [_c(\"blockquote\", [_c(\"p\", [_vm._v(\"类型检查\")])])]),\n      _vm._v(\" \"),\n      _c(\"li\", [_c(\"blockquote\", [_c(\"p\", [_vm._v(\"默认值\")])])])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h3\", { attrs: { id: \"react生命周期\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#react生命周期\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" React生命周期\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"language-js extra-class\" }, [\n      _c(\"pre\", { pre: true, attrs: { class: \"language-js\" } }, [\n        _c(\"code\", [\n          _vm._v(\"实例化阶段\\n\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token number\" } }, [\n            _vm._v(\"1\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token function\" } }, [\n            _vm._v(\"、componentDidMount\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"(\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\")\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token comment\" } }, [\n            _vm._v(\"// 组件挂载完成之后触发的生命周期 相当于vue的mounted\")\n          ]),\n          _vm._v(\"\\n\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token number\" } }, [\n            _vm._v(\"2\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token function\" } }, [\n            _vm._v(\"、componentWillMount\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"(\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\")\")\n          ]),\n          _vm._v(\"  \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token comment\" } }, [\n            _vm._v(\"// 组件挂载之前 相当于vue的beforeMount\")\n          ]),\n          _vm._v(\"\\n\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token function\" } }, [\n            _vm._v(\"更新阶段\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"(\")\n          ]),\n          _vm._v(\"存在期\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\")\")\n          ]),\n          _vm._v(\"\\n\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token number\" } }, [\n            _vm._v(\"3\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token function\" } }, [\n            _vm._v(\"、componentWillReceiveProps\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"(\")\n          ]),\n          _vm._v(\"nextProps\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\")\")\n          ]),\n          _vm._v(\"  \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token comment\" } }, [\n            _vm._v(\"// 组件将要接收新的props vue没有\")\n          ]),\n          _vm._v(\"\\n\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token number\" } }, [\n            _vm._v(\"4\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token function\" } }, [\n            _vm._v(\"、shouldComponentUpdate\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"(\")\n          ]),\n          _vm._v(\"nextProps\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\",\")\n          ]),\n          _vm._v(\"nextState\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\")\")\n          ]),\n          _vm._v(\"  \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token comment\" } }, [\n            _vm._v(\n              \"// 通过返回值判断组件是否需要更新,用于react优化，vue没有 true更新，false不更新\"\n            )\n          ]),\n          _vm._v(\"\\n\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token number\" } }, [\n            _vm._v(\"5\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token function\" } }, [\n            _vm._v(\"、componentWillUpdate\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"(\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\")\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token comment\" } }, [\n            _vm._v(\"// 组件将要更新 相当于vue的beforeUpdate\")\n          ]),\n          _vm._v(\"\\n\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token number\" } }, [\n            _vm._v(\"6\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token function\" } }, [\n            _vm._v(\"、render\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"(\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\")\")\n          ]),\n          _vm._v(\"\\n\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token number\" } }, [\n            _vm._v(\"7\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token function\" } }, [\n            _vm._v(\"、componentDidUpdate\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"(\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\")\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token comment\" } }, [\n            _vm._v(\"// 组件更新完成 相当于vue的updated\")\n          ]),\n          _vm._v(\"\\n销毁\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token operator\" } }, [\n            _vm._v(\"&\")\n          ]),\n          _vm._v(\"清理期\\n\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token number\" } }, [\n            _vm._v(\"8\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token function\" } }, [\n            _vm._v(\"、componentWillUnmount\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"(\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\")\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token comment\" } }, [\n            _vm._v(\"// 组件将要卸载\")\n          ]),\n          _vm._v(\"\\n\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token number\" } }, [\n            _vm._v(\"9\")\n          ]),\n          _vm._v(\"、方法\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\":\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token function\" } }, [\n            _vm._v(\"unmountComponentAtNode\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"(\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\")\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token comment\" } }, [\n            _vm._v(\n              \"// eg: ReactDom.unmountComponentAtNode(document.getElementById('root'))\"\n            )\n          ]),\n          _vm._v(\"\\n\")\n        ])\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h3\", { attrs: { id: \"react组件\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#react组件\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" React组件\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"blockquote\", [\n      _c(\"ul\", [\n        _c(\"li\", [_vm._v(\"无状态组件(视图组件)\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"class 继承 （容器组件）\")])\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h3\", { attrs: { id: \"redux\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#redux\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" Redux\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h3\", { attrs: { id: \"redux中间件\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#redux中间件\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" Redux中间件\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h3\", { attrs: { id: \"组件通信\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#组件通信\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" 组件通信\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h3\", { attrs: { id: \"高阶组件\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#高阶组件\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" 高阶组件\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h3\", { attrs: { id: \"mobx\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#mobx\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" mobx\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"blockquote\", [\n      _c(\"p\", [\n        _vm._v(\n          \"当应用状态更新时，所有依赖于这些应用状态的监听者（包括 UI、服务端数据同步函数等），都应该自动得到细粒度地更新。\"\n        )\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"language-js extra-class\" }, [\n      _c(\"pre\", { pre: true, attrs: { class: \"language-js\" } }, [\n        _c(\"code\", [\n          _c(\n            \"span\",\n            { pre: true, attrs: { class: \"token function-variable function\" } },\n            [_vm._v(\"shouldComponentUpdate\")]\n          ),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\":\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token keyword\" } }, [\n            _vm._v(\"function\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"(\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token parameter\" } }, [\n            _vm._v(\"nextProps\"),\n            _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\",\")\n            ]),\n            _vm._v(\" nextState\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\")\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"{\")\n          ]),\n          _vm._v(\"\\n  \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token operator\" } }, [\n            _vm._v(\"...\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token operator\" } }, [\n            _vm._v(\"...\")\n          ]),\n          _vm._v(\"\\n  \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token comment\" } }, [\n            _vm._v(\"// update on any state changes (as is the default)\")\n          ]),\n          _vm._v(\"\\n  \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token keyword\" } }, [\n            _vm._v(\"if\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"(\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token keyword\" } }, [\n            _vm._v(\"this\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\".\")\n          ]),\n          _vm._v(\"state \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token operator\" } }, [\n            _vm._v(\"!==\")\n          ]),\n          _vm._v(\" nextState\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\")\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"{\")\n          ]),\n          _vm._v(\"\\n    \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token keyword\" } }, [\n            _vm._v(\"return\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token boolean\" } }, [\n            _vm._v(\"true\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\";\")\n          ]),\n          _vm._v(\"\\n  \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"}\")\n          ]),\n          _vm._v(\"\\n  \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token comment\" } }, [\n            _vm._v(\"// update if props are shallowly not equal\")\n          ]),\n          _vm._v(\"\\n  \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token keyword\" } }, [\n            _vm._v(\"return\")\n          ]),\n          _vm._v(\" \"),\n          _c(\"span\", { pre: true, attrs: { class: \"token function\" } }, [\n            _vm._v(\"isObjectShallowModified\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"(\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token keyword\" } }, [\n            _vm._v(\"this\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\".\")\n          ]),\n          _vm._v(\"props\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\",\")\n          ]),\n          _vm._v(\" nextProps\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\")\")\n          ]),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\";\")\n          ]),\n          _vm._v(\"\\n\"),\n          _c(\"span\", { pre: true, attrs: { class: \"token punctuation\" } }, [\n            _vm._v(\"}\")\n          ]),\n          _vm._v(\"\\n\")\n        ])\n      ])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h2\", { attrs: { id: \"知识拓展\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#知识拓展\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" 知识拓展\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h3\", { attrs: { id: \"react-native\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#react-native\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" React Native\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h4\", { attrs: { id: \"优势\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#优势\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" 优势\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ul\", [\n      _c(\"li\", [_vm._v(\"跨平台 （只有 0.2% 的平台特定代码）\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"统一的设计语言，同时还能为不同平台提供不同设计\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"React 的 scale 很好。组件化，简单的生命周期,声明式\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"迭代速度快（主要是 hot reloading 很快）\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\n          \"大量基础设施的投入值得（网络、国际化、复杂动画、设备信息、用户信息等等都是通过一- 个桥把原生 api 暴露给 RN 的。）\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\n          \"同时他们在这里也指出：他们并不相信在一个已有 app 上集成 RN 是一件简单事儿，必须- 要大量且持续地投入基础设施才行（说好的「满意的地方」呢）\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"性能 （尽管大家都担心但是其实基本没有问题）\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\n          \"不过首次渲染比较慢，导致不适合用作启动屏、deeplink，也增加了可交互时间（TTI），另外掉帧不好 debug（说好的「满意的地方」呢）\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"Redux（好用，虽然废话太多）\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\n          \"背后是原生，一些曾经不确定能不能做的功能（Shared element transitions、动画库 Lottie、网络层、核心基础设施）发现都能做\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"静态分析（eslint，prettier，一些性能检测）\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"动画\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"JS/React 的开源生态\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"Flexbox\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"有时候可以加上 Web 跨三端\")])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h4\", { attrs: { id: \"劣势\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#劣势\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" 劣势\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ul\", [\n      _c(\"li\", [_vm._v(\"论成熟度，稳定性，RN 比 不上 iOS 和 Android 原生。\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\"由于 RN 的 Bug，有时我们必须维护自己的一个 RN 分支。\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\"JS 缺少类型系统，Flow 太严格，TS 集成到已有项目也还有问题。\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\n          \"不好重构（JS 没有类型无法静态分析，重构引起的错误不能在编译时被捕捉到）\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\n          \"JavaScriptCore 不一致性，更糟糕的是，现在都 8102 年了，RN （Android）带的还是不支持 ES 6 的 JSC\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\n          \"RN 开源库质量参差不齐。比如在 iOS 上正常的库在 Android 上可能有意想不到的错误（因为为作者也许只熟悉 iOS 和 RN,并不熟悉 Android）\\n有时不得不白手起家，因为很多的基础框架中的库还没有 的 RN 封装。\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\"崩溃监控库在 RN 上表现不是特别特定业。内没方案，只能自己搞。\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\n          \"Native Bridge 的由于 JS 的弱类型造成 Native 与 JS 通信 中类型的不匹配，容易造成错误。\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\"启动时间，RN 框架初始化需要几秒，即使是在高端机器上。\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"新开页面的渲染时间，0.4 秒左右页面第一次渲染费时。\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"APP 大小。至少增加 12M。\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"直到目前都无法在 Android 上支持 64 位。\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\n          \"手势，iOS 和 Android 的手势 API 差距很大，不过喜闻 react-native-gesture-handler 发布了 1.0 版本。\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [\n        _vm._v(\n          \"长列表，虽然 RN 团队很努力了，但是由于 RN 的异步通信机制，长列表的流畅渲染，目前依然无解。\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"React Native 升级是个坑。\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"RN 中的 Accessibility 就是个大坑。\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"还有一些奇怪的 Bug，暂没有修复。\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"SavedInstanceState 在 Android 上跨进程的坑。\")])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h4\", { attrs: { id: \"不是技术问题的问题\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#不是技术问题的问题\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" 不是技术问题的问题\")\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"ul\", [\n      _c(\"li\", [\n        _vm._v(\n          \"要用好 RN 你必须同时熟悉 iOS 和 Android ，当然还有 RN 本身，这就对我们工程师提出了更多挑战。\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"团队的管理，责任的划分。\")]),\n      _vm._v(\" \"),\n      _c(\"li\", [_vm._v(\"RN 文档及相关资源不如 iOS 和 Android 的丰富。\")])\n    ])\n  },\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"h2\", { attrs: { id: \"学习链接\" } }, [\n      _c(\n        \"a\",\n        {\n          staticClass: \"header-anchor\",\n          attrs: { href: \"#学习链接\", \"aria-hidden\": \"true\" }\n        },\n        [_vm._v(\"#\")]\n      ),\n      _vm._v(\" 学习链接\")\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}