{"remainingRequest":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!D:\\1\\实训一\\study\\study\\lib\\webpack\\markdownLoader.js??ref--1-2!D:\\1\\实训一\\study\\study\\src\\zh\\chain\\README.md?vue&type=template&id=d9daf6ae&","dependencies":[{"path":"D:\\1\\实训一\\study\\study\\src\\zh\\chain\\README.md","mtime":1557200317053},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\lib\\webpack\\markdownLoader.js","mtime":1557200316988}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"react\"><a class=\"header-anchor\" href=\"#react\" aria-hidden=\"true\">#</a> React</h1>\n<p>在使用 react 的过程中，我们绕不开渲染性能优化问题，因为默认情况下 react 组件的 shouldComponentUpdate 函数会一直返回 true，这回导致所有的组件都会进行耗时的虚拟 DOM 比较。在使用 redux 作为 react 的逻辑层框架时，我们可以使用经典的 PureComponent+ShallowCompare 的方式进行渲染性能优化</p>\n<p>https://foio.github.io/mobx-react/</p>\n<h2 id=\"学习重点划分\"><a class=\"header-anchor\" href=\"#学习重点划分\" aria-hidden=\"true\">#</a> 学习重点划分</h2>\n<h3 id=\"jsx是什么\"><a class=\"header-anchor\" href=\"#jsx是什么\" aria-hidden=\"true\">#</a> jsx是什么?</h3>\n<ul>\n<li>React 使用 JSX 来替代常规的 JavaScript</li>\n<li>JSX 是一个看起来很像 XML 的 JavaScript 语法扩展</li>\n<li>我们不需要一定使用 JSX，但它有以下优点</li>\n</ul>\n<ol>\n<li>\n<blockquote>\n<p>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化</p>\n</blockquote>\n</li>\n<li>\n<blockquote>\n<p>它是类型安全的，在编译过程中就能发现错误</p>\n</blockquote>\n</li>\n<li>\n<blockquote>\n<p>使用 JSX 编写模板更加简单快速</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"mvvm是什么？\"><a class=\"header-anchor\" href=\"#mvvm是什么？\" aria-hidden=\"true\">#</a> MVVM是什么？</h3>\n<ol>\n<li>MVVM是Model-View-ViewModel的简写</li>\n<li>它本质上是MVC 的改进版</li>\n<li>MVVM（Model-View-ViewModel）框架的由来是MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构框架</li>\n</ol>\n<h4 id=\"mvvm优点\"><a class=\"header-anchor\" href=\"#mvvm优点\" aria-hidden=\"true\">#</a> MVVM优点</h4>\n<ul>\n<li>\n<blockquote>\n<p>MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li><strong>低耦合</strong>：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变</li>\n<li><strong>可重用性</strong>：你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑</li>\n<li><strong>独立开发</strong>：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码</li>\n<li><strong>可测试</strong>：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</li>\n</ol>\n<h3 id=\"props\"><a class=\"header-anchor\" href=\"#props\" aria-hidden=\"true\">#</a> Props</h3>\n<ul>\n<li>\n<blockquote>\n<p>和props相关</p>\n</blockquote>\n<ul>\n<li>只读，不准修改</li>\n<li>componentWillReceiveProps  / 生命周期</li>\n<li>propTypes</li>\n<li>defaultProps</li>\n<li>children</li>\n</ul>\n</li>\n<li>\n<blockquote>\n<p>类型检查</p>\n</blockquote>\n</li>\n<li>\n<blockquote>\n<p>默认值</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"react生命周期\"><a class=\"header-anchor\" href=\"#react生命周期\" aria-hidden=\"true\">#</a> React生命周期</h3>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code>实例化阶段\n<span class=\"token number\">1</span><span class=\"token function\">、componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 组件挂载完成之后触发的生命周期 相当于vue的mounted</span>\n<span class=\"token number\">2</span><span class=\"token function\">、componentWillMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 组件挂载之前 相当于vue的beforeMount</span>\n<span class=\"token function\">更新阶段</span><span class=\"token punctuation\">(</span>存在期<span class=\"token punctuation\">)</span>\n<span class=\"token number\">3</span><span class=\"token function\">、componentWillReceiveProps</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 组件将要接收新的props vue没有</span>\n<span class=\"token number\">4</span><span class=\"token function\">、shouldComponentUpdate</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">,</span>nextState<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 通过返回值判断组件是否需要更新,用于react优化，vue没有 true更新，false不更新</span>\n<span class=\"token number\">5</span><span class=\"token function\">、componentWillUpdate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 组件将要更新 相当于vue的beforeUpdate</span>\n<span class=\"token number\">6</span><span class=\"token function\">、render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token number\">7</span><span class=\"token function\">、componentDidUpdate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 组件更新完成 相当于vue的updated</span>\n销毁<span class=\"token operator\">&amp;</span>清理期\n<span class=\"token number\">8</span><span class=\"token function\">、componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 组件将要卸载</span>\n<span class=\"token number\">9</span>、方法<span class=\"token punctuation\">:</span><span class=\"token function\">unmountComponentAtNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// eg: ReactDom.unmountComponentAtNode(document.getElementById('root'))</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"react组件\"><a class=\"header-anchor\" href=\"#react组件\" aria-hidden=\"true\">#</a> React组件</h3>\n<blockquote>\n<ul>\n<li>无状态组件(视图组件)</li>\n<li>class 继承 （容器组件）</li>\n</ul>\n</blockquote>\n<h3 id=\"redux\"><a class=\"header-anchor\" href=\"#redux\" aria-hidden=\"true\">#</a> Redux</h3>\n<h3 id=\"redux中间件\"><a class=\"header-anchor\" href=\"#redux中间件\" aria-hidden=\"true\">#</a> Redux中间件</h3>\n<h3 id=\"组件通信\"><a class=\"header-anchor\" href=\"#组件通信\" aria-hidden=\"true\">#</a> 组件通信</h3>\n<h3 id=\"高阶组件\"><a class=\"header-anchor\" href=\"#高阶组件\" aria-hidden=\"true\">#</a> 高阶组件</h3>\n<h3 id=\"mobx\"><a class=\"header-anchor\" href=\"#mobx\" aria-hidden=\"true\">#</a> mobx</h3>\n<p>作为一个数据层框架，mobx 基于一个最简单的原则：</p>\n<blockquote>\n<p>当应用状态更新时，所有依赖于这些应用状态的监听者（包括 UI、服务端数据同步函数等），都应该自动得到细粒度地更新。</p>\n</blockquote>\n<p>在使用 mobx 作为 react 的 store 时，我们该如何进行渲染性能优化呢？\n通过分析源代码发现，在使用@observer 将 react 组件转换成一个监听者(Reactions)后，mobx 会为 react 组件提供一个精确的、细粒度的 shouldComponentUpdate 函数:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token function-variable function\">shouldComponentUpdate</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextProps<span class=\"token punctuation\">,</span> nextState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span><span class=\"token operator\">...</span>\n  <span class=\"token comment\">// update on any state changes (as is the default)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">!==</span> nextState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// update if props are shallowly not equal</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">isObjectShallowModified</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>借助于 mobx 框架对 Observable 变量引用的跟踪和依赖收集，mobx 能够精确地得到 react 组件对 Observable 变量的依赖图谱，然后再用经典的 ShallowCompare 实现细粒度的 shouldComponentUpdate 函数，以达到 100%无浪费 render。这一切都是自动完成地，fantastic！使用 mobx 后，我们再也无需手动写 shouldComponentUpdate 函数了。</p>\n<h2 id=\"知识拓展\"><a class=\"header-anchor\" href=\"#知识拓展\" aria-hidden=\"true\">#</a> 知识拓展</h2>\n<h3 id=\"react-native\"><a class=\"header-anchor\" href=\"#react-native\" aria-hidden=\"true\">#</a> React Native</h3>\n<h4 id=\"优势\"><a class=\"header-anchor\" href=\"#优势\" aria-hidden=\"true\">#</a> 优势</h4>\n<ul>\n<li>跨平台 （只有 0.2% 的平台特定代码）</li>\n<li>统一的设计语言，同时还能为不同平台提供不同设计</li>\n<li>React 的 scale 很好。组件化，简单的生命周期,声明式</li>\n<li>迭代速度快（主要是 hot reloading 很快）</li>\n<li>大量基础设施的投入值得（网络、国际化、复杂动画、设备信息、用户信息等等都是通过一- 个桥把原生 api 暴露给 RN 的。）</li>\n<li>同时他们在这里也指出：他们并不相信在一个已有 app 上集成 RN 是一件简单事儿，必须- 要大量且持续地投入基础设施才行（说好的「满意的地方」呢）</li>\n<li>性能 （尽管大家都担心但是其实基本没有问题）</li>\n<li>不过首次渲染比较慢，导致不适合用作启动屏、deeplink，也增加了可交互时间（TTI），另外掉帧不好 debug（说好的「满意的地方」呢）</li>\n<li>Redux（好用，虽然废话太多）</li>\n<li>背后是原生，一些曾经不确定能不能做的功能（Shared element transitions、动画库 Lottie、网络层、核心基础设施）发现都能做</li>\n<li>静态分析（eslint，prettier，一些性能检测）</li>\n<li>动画</li>\n<li>JS/React 的开源生态</li>\n<li>Flexbox</li>\n<li>有时候可以加上 Web 跨三端</li>\n</ul>\n<h4 id=\"劣势\"><a class=\"header-anchor\" href=\"#劣势\" aria-hidden=\"true\">#</a> 劣势</h4>\n<ul>\n<li>论成熟度，稳定性，RN 比 不上 iOS 和 Android 原生。</li>\n<li>由于 RN 的 Bug，有时我们必须维护自己的一个 RN 分支。</li>\n<li>JS 缺少类型系统，Flow 太严格，TS 集成到已有项目也还有问题。</li>\n<li>不好重构（JS 没有类型无法静态分析，重构引起的错误不能在编译时被捕捉到）</li>\n<li>JavaScriptCore 不一致性，更糟糕的是，现在都 8102 年了，RN （Android）带的还是不支持 ES 6 的 JSC</li>\n<li>RN 开源库质量参差不齐。比如在 iOS 上正常的库在 Android 上可能有意想不到的错误（因为为作者也许只熟悉 iOS 和 RN,并不熟悉 Android）\n有时不得不白手起家，因为很多的基础框架中的库还没有 的 RN 封装。</li>\n<li>崩溃监控库在 RN 上表现不是特别特定业。内没方案，只能自己搞。</li>\n<li>Native Bridge 的由于 JS 的弱类型造成 Native 与 JS 通信 中类型的不匹配，容易造成错误。</li>\n<li>启动时间，RN 框架初始化需要几秒，即使是在高端机器上。</li>\n<li>新开页面的渲染时间，0.4 秒左右页面第一次渲染费时。</li>\n<li>APP 大小。至少增加 12M。</li>\n<li>直到目前都无法在 Android 上支持 64 位。</li>\n<li>手势，iOS 和 Android 的手势 API 差距很大，不过喜闻 react-native-gesture-handler 发布了 1.0 版本。</li>\n<li>长列表，虽然 RN 团队很努力了，但是由于 RN 的异步通信机制，长列表的流畅渲染，目前依然无解。</li>\n<li>React Native 升级是个坑。</li>\n<li>RN 中的 Accessibility 就是个大坑。</li>\n<li>还有一些奇怪的 Bug，暂没有修复。</li>\n<li>SavedInstanceState 在 Android 上跨进程的坑。</li>\n</ul>\n<h4 id=\"不是技术问题的问题\"><a class=\"header-anchor\" href=\"#不是技术问题的问题\" aria-hidden=\"true\">#</a> 不是技术问题的问题</h4>\n<ul>\n<li>要用好 RN 你必须同时熟悉 iOS 和 Android ，当然还有 RN 本身，这就对我们工程师提出了更多挑战。</li>\n<li>团队的管理，责任的划分。</li>\n<li>RN 文档及相关资源不如 iOS 和 Android 的丰富。</li>\n</ul>\n<h2 id=\"学习链接\"><a class=\"header-anchor\" href=\"#学习链接\" aria-hidden=\"true\">#</a> 学习链接</h2>\n<p><a href=\"https://github.com/semlinker/reactjs-interview-questions\" target=\"_blank\" rel=\"noopener noreferrer\">reactjs-interview-questions<OutboundLink/></a></p>\n</div>\n",null]}