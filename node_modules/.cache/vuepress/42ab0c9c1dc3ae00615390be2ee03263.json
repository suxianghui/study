{"remainingRequest":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!D:\\1\\实训一\\study\\study\\lib\\webpack\\markdownLoader.js??ref--1-2!D:\\1\\实训一\\study\\study\\src\\zh\\miniapp\\小程序路由.md?vue&type=template&id=2a9c00f5&","dependencies":[{"path":"D:\\1\\实训一\\study\\study\\src\\zh\\miniapp\\小程序路由.md","mtime":1557200317078},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\lib\\webpack\\markdownLoader.js","mtime":1557200316988}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"小程序路由\"><a class=\"header-anchor\" href=\"#小程序路由\" aria-hidden=\"true\">#</a> 小程序路由</h1>\n<h5 id=\"_1、路由管理\"><a class=\"header-anchor\" href=\"#_1、路由管理\" aria-hidden=\"true\">#</a> 1、路由管理</h5>\n<ul>\n<li>在小程序中所有页面的路由全部由框架进行管理，框架以栈的形式维护了当前的所有页面。</li>\n</ul>\n<h5 id=\"_2、栈（计算机术语）\"><a class=\"header-anchor\" href=\"#_2、栈（计算机术语）\" aria-hidden=\"true\">#</a> 2、栈（计算机术语）</h5>\n<ul>\n<li>栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</li>\n<li>可进可出（进是添加，处删除），也就意味这小程序中可以跳转新页面，可以后退，但是不能前进</li>\n</ul>\n<h5 id=\"_3、浏览器如何管理浏览记录\"><a class=\"header-anchor\" href=\"#_3、浏览器如何管理浏览记录\" aria-hidden=\"true\">#</a> 3、浏览器如何管理浏览记录</h5>\n<ul>\n<li>浏览器以浏览新网页的形式将所有浏览都保留在历史记录，任何浏览都会保存，后退不会删除浏览器记录，也就意味着可以前进</li>\n</ul>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>场景\nA页面    A页面进栈\nA页面 -&gt; B页面   B页面进栈\nB页面 -&gt;  C页面  C页面进栈\nC页面后退    C页面出栈\nB页面 -&gt;  D页面   D页面进栈\n[A,B,D]\n\nD页面打开  A页面   在一个A页面进栈\n</code></pre>\n<!--beforeend--></div><!--afterend--><h5 id=\"_4、getcurrentpages\"><a class=\"header-anchor\" href=\"#_4、getcurrentpages\" aria-hidden=\"true\">#</a> 4、getCurrentPages()</h5>\n<ul>\n<li>该函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。在小程序中栈最多只能维护10个数据</li>\n</ul>\n<h5 id=\"_5、栈的表现\"><a class=\"header-anchor\" href=\"#_5、栈的表现\" aria-hidden=\"true\">#</a> 5、栈的表现</h5>\n<ul>\n<li>打开新页面 -&gt; 进栈</li>\n<li>后退 -&gt; 当前页面出栈</li>\n<li>重定向  -&gt; 当期页面出栈新页面入栈</li>\n<li>重加载  -&gt; 页面全部出栈保留当期页面栈</li>\n<li>Tab 切换 -&gt;\t页面全部出栈，只留下新的 Tab 页面</li>\n</ul>\n<h5 id=\"_5、路由跳转方式\"><a class=\"header-anchor\" href=\"#_5、路由跳转方式\" aria-hidden=\"true\">#</a> 5、路由跳转方式</h5>\n<ul>\n<li>在小程序中路由跳转方式有两种（组件跳转，api跳转）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>跳转形式</th>\n<th>Api</th>\n<th>组件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>打开新页面</td>\n<td>wx.navigateTo(‘路径’)</td>\n<td>&lt;\\navigator open-type=&quot;navigateTo&quot;/&gt;</td>\n</tr>\n<tr>\n<td>页面重定向</td>\n<td>wx.redirectTo</td>\n<td>&lt;\\navigator open-type=&quot;redirectTo&quot;/&gt;</td>\n</tr>\n<tr>\n<td>页面返回</td>\n<td>wx.navigateBack</td>\n<td>&lt;\\navigator open-type=&quot;navigateBack&quot;&gt;</td>\n</tr>\n<tr>\n<td>Tab 切换</td>\n<td>wx.switchTab</td>\n<td>&lt;\\navigator open-type=&quot;switchTab&quot;/&gt;</td>\n</tr>\n<tr>\n<td>重启动</td>\n<td>wx.reLaunch</td>\n<td>&lt;\\navigator open-type=&quot;reLaunch&quot;/&gt;</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"注意\"><a class=\"header-anchor\" href=\"#注意\" aria-hidden=\"true\">#</a> 注意:</h4>\n<ul>\n<li>navigateTo, redirectTo 只能打开非 tabBar 页面。</li>\n<li>switchTab 只能打开 tabBar 页面。</li>\n<li>reLaunch 可以打开任意页面。</li>\n<li>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</li>\n<li>调用页面路由带的参数可以在目标页面的onLoad中获取</li>\n<li>页面只有在出栈后才会被卸载也就是执行onUnload, tab页面只有在程序卸载的时候才会卸载</li>\n</ul>\n</div>\n",null]}