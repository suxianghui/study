{"remainingRequest":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!D:\\1\\实训一\\study\\study\\lib\\webpack\\markdownLoader.js??ref--1-2!D:\\1\\实训一\\study\\study\\src\\zh\\standard\\Standard.md?vue&type=template&id=2f8bd956&","dependencies":[{"path":"D:\\1\\实训一\\study\\study\\src\\zh\\standard\\Standard.md","mtime":1557200317085},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\lib\\webpack\\markdownLoader.js","mtime":1557200316988}],"contextDependencies":[],"result":["\n<div class=\"content\"><h2 id=\"目录规范\"><a class=\"header-anchor\" href=\"#目录规范\" aria-hidden=\"true\">#</a> 目录规范</h2>\n<p>├── build                      // 构建相关<br>\n├── config                     // 配置相关<br>\n├── src                        // 源代码<br>\n│   ├── api                    // 所有请求<br>\n│   ├── assets                 // 主题 字体等静态资源<br>\n│   ├── components             // 全局公用组件<br>\n│   ├── directive              // 全局指令<br>\n│   ├── filters                // 全局 filter<br>\n│   ├── icons                  // 项目所有 svg icons<br>\n│   ├── lang                   // 国际化 language<br>\n│   ├── mock                   // 项目mock 模拟数据<br>\n│   ├── router                 // 路由<br>\n│   ├── store                  // 全局 store管理<br>\n│   ├── styles                 // 全局样式<br>\n│   ├── utils                  // 全局公用方法<br>\n│   ├── vendor                 // 公用vendor<br>\n│   ├── views                  // views 所有页面<br>\n│   ├── App.vue                // 入口页面<br>\n│   ├── main.js                // 入口文件 加载组件 初始化等<br>\n│   └── permission.js          // 权限管理<br>\n├── static                     // 第三方不打包资源<br>\n│   └── Tinymce                // 富文本<br>\n├── .babelrc                   // babel-loader 配置<br>\n├── .eslintrc.js               // eslint 配置项<br>\n├── .gitignore                 // git 忽略项<br>\n├── .travis.yml                // 自动化CI配置<br>\n├── favicon.ico                // favicon图标<br>\n├── index.html                 // html模板<br>\n└── package.json               // package.json</p>\n<h2 id=\"命名规范\"><a class=\"header-anchor\" href=\"#命名规范\" aria-hidden=\"true\">#</a> 命名规范</h2>\n<p>1 避免单字母的名字。用你的命名来描述功能（最好使用动词命名）。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function query() {\n  // ...\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>2 在命名对象、函数和实例时使用驼峰命名法（camelCase）。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const thisIsMyObject = {};\nfunction thisIsMyFunction() {}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>3 只有在命名构造器或者类的时候才用帕斯卡拼命名法。<em>（PascalCase 每个单词的第一个字母都大写）</em></p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class User {\n  constructor(options) {\n    this.name = options.name;\n  }\n}\nconst good = new User({\n  name: &#39;yup&#39;,\n});\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>4 不要使用前置或者后置下划线。</p>\n<p>5 文件名应该和默认导出的名称完全匹配。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class CheckBox {\n  // ...\n}\nexport default CheckBox;\nexport default function fortyTwo() { return 42; }\nimport CheckBox from &#39;./CheckBox&#39;; // PascalCase export/import/filename\nimport fortyTwo from &#39;./fortyTwo&#39;; // camelCase export/import/filename\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>8 当你导出一个构造器 / 类 / 单例 / 函数库 / 暴露的对象时应该使用帕斯卡命名法。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const AirbnbStyleGuide = {\n  es6: {\n  },\n};\nexport default AirbnbStyleGuide;\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>9 缩略词和缩写都必须是全部大写或者全部小写。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>import SMSContainer from &#39;./containers/SMSContainer&#39;;\nconst HTTPRequests = [\n  // ...\n];\nconst httpRequests = [\n  // ...\n];\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"变量\"><a class=\"header-anchor\" href=\"#变量\" aria-hidden=\"true\">#</a> 变量</h2>\n<p>1 使用 const 或者 let 来定义变量。避免污染全局命名空间。（最好使用名词命名）\n把 const 声明的放在一起，把 let 声明的放在一起。.\n这在后边如果需要根据前边的赋值变量指定一个变量时很有用。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const superPower = new SuperPower();\nconst goSportsTeam = true;\nlet dragonball;\nlet i;\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>2 在你需要的使用定义变量，但是要把它们放在一个合理的地方。\nlet 和 const 是块级作用域而不是函数作用域。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function checkName(hasName) {\n  if (hasName === &#39;test&#39;) {\n    return false;\n  }\n  const name = getName();\n  if (name === &#39;test&#39;) {\n    this.setName(&#39;&#39;);\n    return false;\n  }\n  return name;\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>3 不要链式变量赋值。\n链式变量赋值会创建隐式全局变量。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>(function example() {\n  let a = 1;\n  let b = a;\n  let c = a;\n}());\nconsole.log(a); // throws ReferenceError\nconsole.log(b); // throws ReferenceError\nconsole.log(c); // throws ReferenceError\n// 对于 `const` 也一样\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"注释\"><a class=\"header-anchor\" href=\"#注释\" aria-hidden=\"true\">#</a> 注释</h2>\n<p>1 使用 /** ... */ 来进行多行注释。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>/**\n* make() returns a new element\n* based on the passed-in tag name\n*/\nfunction make(tag) {\n  // ...\n  return element;\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>2 使用 // 进行单行注释。 将单行注释放在需要注释的行的上方新行。 在注释之前放一个空行，除非它在块的第一行。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>// 注释\nfunction getType() {\n  console.log(&#39;fetching type...&#39;);\n\n  // set the default type to &#39;no type&#39;\n  const type = this.type || &#39;no type&#39;;\n  return type;\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"空格\"><a class=\"header-anchor\" href=\"#空格\" aria-hidden=\"true\">#</a> 空格</h2>\n<p>1 使用 tabs (空格字符) 设置为 2 个空格。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function baz() {\n∙∙let name;\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>2 在主体前放置一个空格。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function test() {\n  console.log(&#39;test&#39;);\n}\ndog.set(&#39;attr&#39;, {\n  age: &#39;1 year&#39;,\n  breed: &#39;Bernese Mountain Dog&#39;,\n});\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>3 在控制语句（if, while 等）开始括号之前放置一个空格。 在函数调用和是声明中，在参数列表和函数名之间没有空格。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>if (isJedi) {\n  fight();\n}\nfunction fight() {\n  console.log(&#39;Swooosh!&#39;);\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>4 用空格分离操作符。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const x = y + 5;\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>5 在块和下一个语句之前留下一空白行。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const arr = [\n  function foo() {\n  },\n\n  function bar() {\n  },\n];\n\nreturn arr;\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>6 不要在括号内添加空格。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>if (foo) {\n  console.log(foo);\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>7 不要在中括号中添加空格。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const foo = [1, 2, 3];\nconsole.log(foo[0]);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>8 在花括号内添加空格。\nconst foo = { clark: 'kent' };</p>\n<p>9 要求打开的块标志和同一行上的标志拥有一致的间距。此规则还会在同一行关闭的块标记和前边的标记强    制实施一致的间距。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function foo() { return true; }\nif (foo) { bar = 0; }\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>10 逗号之前避免使用空格，逗号之后需要使用空格。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var foo = 1, bar = 2;\nvar arr = [1, 2];\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>11 在行的末尾避免使用空格。</p>\n<h2 id=\"分号\"><a class=\"header-anchor\" href=\"#分号\" aria-hidden=\"true\">#</a> 分号</h2>\n<p>每一行结束加分号结尾</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const luke = {};\nconst leia = {};\n[luke, leia].forEach((jedi) =&gt; {\n  jedi.father = &#39;vader&#39;;\n});\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"方法\"><a class=\"header-anchor\" href=\"#方法\" aria-hidden=\"true\">#</a> 方法</h2>\n<p>1 使用命名的函数表达式代替函数声明。\n函数声明是挂起的，这意味着在它在文件中定义之前，很容易引用函数。这会损害可读性和可维护性。\n// 从变量引用调用中区分的词汇名称</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const short = function longUniqueMoreDescriptiveLexicalFoo() {\n  // ...\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>2 Wrap立即调用函数表达式。\n立即调用的函数表达式是单个单元 - 包装， 并且拥有括号调用, 在括号内, 清晰的表达式。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>(function () {\n  console.log(&#39;Welcome to the Internet. Please follow me.&#39;);\n}());\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>3 切记不要在非功能块中声明函数 (if, while, 等)。 将函数赋值给变量。</p>\n<p>4 避免使用默认参数的副作用。\n他们很容易混淆。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var b = 1;\ncount();  // 1\ncount();  // 2\ncount(3); // 3\ncount();  // 3\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>5 总是把默认参数放在最后。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function handleThings(name, opts = {}) {\n  // ...\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>6 函数签名中的间距。\n一致性很好，在删除或添加名称时不需要添加或删除空格。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const x = function () {};\nconst y = function a() {};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>7 优先使用扩展运算符 ... 来调用可变参数函数\n它更加干净，你不需要提供上下文。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const x = [1, 2, 3, 4, 5];\nconsole.log(...x);\nnew Date(...[2016, 8, 5]);\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"箭头函数\"><a class=\"header-anchor\" href=\"#箭头函数\" aria-hidden=\"true\">#</a> 箭头函数</h2>\n<p>1 当你必须使用匿名函数时 (当传递内联函数时)， 使用箭头函数。\n它创建了一个在 this 上下文中执行的函数版本，它通常是你想要的，并且是一个更简洁的语法。\n如果你有一个相当复杂的函数，你可以把这个逻辑转移到它自己的命名函数表达式中。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>[1, 2, 3].map((x) =&gt; {\n  const y = x + 1;\n  return x * y;\n});\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>2 如果表达式跨越多个行，用括号将其括起来，以获得更好的可读性。\n它清楚地显示了函数的起点和终点。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>[&#39;get&#39;, &#39;post&#39;, &#39;put&#39;].map(httpMethod =&gt; (\n  Object.prototype.hasOwnProperty.call(\n    httpMagicObjectWithAVeryLongName,\n    httpMethod,\n  )\n));\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>3 如果你的函数接收一个参数，则可以不用括号，省略括号。 否则，为了保证清晰和一致性，需要在参数周围加上括号。\n注意：总是使用括号是可以接受的，在这种情况下，我们使用 “always” option 来配置减少视觉上的混乱。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>[1, 2, 3].map(x =&gt; x * x);\n[1, 2, 3].map(number =&gt; (\n  `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!`\n));\n[1, 2, 3].map((x) =&gt; {\n  const y = x + 1;\n  return x * y;\n});\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>4 避免箭头函数符号 (=&gt;) 和比较运算符 (&lt;=, &gt;=) 的混淆。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const itemHeight = item =&gt; (item.height &gt; 256 ? item.largeSize : item.smallSize);\nconst itemHeight = (item) =&gt; {\n  const { height, largeSize, smallSize } = item;\n  return height &gt; 256 ? largeSize : smallSize;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>5 注意带有隐式返回的箭头函数函数体的位置。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>(foo) =&gt; bar;\n(foo) =&gt; (bar);\n(foo) =&gt; (\n  bar\n)\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"类和构造器\"><a class=\"header-anchor\" href=\"#类和构造器\" aria-hidden=\"true\">#</a> 类和构造器</h2>\n<p>1 尽量使用 class. 避免直接操作 prototype .\nclass 语法更简洁，更容易推理。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class Queue {\n  constructor(contents = []) {\n    this.queue = [...contents];\n  }\n  pop() {\n    const value = this.queue[0];\n    this.queue.splice(0, 1);\n    return value;\n  }\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>2 使用 extends 来扩展继承。\n它是一个内置的方法，可以在不破坏 instanceof 的情况下继承原型功能。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class PeekableQueue extends Queue {\n  peek() {\n    return this.queue[0];\n  }\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>3 方法返回了 this 来供其内部方法调用。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class Jedi {\n  jump() {\n    this.jumping = true;\n    return this;\n  }\n  setHeight(height) {\n    this.height = height;\n    return this;\n  }\n}\nconst luke = new Jedi();\nluke.jump()\n.setHeight(20);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>4 如果没有指定类，则类具有默认的构造器。 一个空的构造器或是一个代表父类的函数是没有必要的。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class Rey extends Jedi {\n  constructor(...args) {\n    super(...args);\n    this.name = &#39;Rey&#39;;\n  }\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>6 避免定义重复的类成员。\n重复的类成员声明将会默认倾向于最后一个 - 具有重复的类成员可以说是一个错误。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class Foo {\n  bar() { return 1; }\n}\nclass Foo {\n  bar() { return 2; }\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>##模块</p>\n<p>1 你可能经常使用模块 (import/export) 在一些非标准模块的系统上。 你也可以在你喜欢的模块系统上相互转换。\n模块是未来的趋势，让我们拥抱未来。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>import AirbnbStyleGuide from &#39;./AirbnbStyleGuide&#39;;\nexport default AirbnbStyleGuide.es6;\nimport { es6 } from &#39;./AirbnbStyleGuide&#39;;\nexport default es6;\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>2 不要使用通配符导入。\n这确定你有一个单独的默认导出。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>import AirbnbStyleGuide from &#39;./AirbnbStyleGuide&#39;;\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>3 不要直接从导入导出。\n虽然写在一行很简洁，但是有一个明确的导入和一个明确的导出能够保证一致性。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>// filename es6.js\nimport { es6 } from &#39;./AirbnbStyleGuide&#39;;\nexport default es6;\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>4 只从一个路径导入所有需要的东西。\n从同一个路径导入多个行，使代码更难以维护。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>import foo, { named1, named2 } from &#39;foo&#39;;\nimport foo, {\n  named1,\n  named2,\n} from &#39;foo&#39;;\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>5 不要导出可变的引用。\n在一般情况下，应该避免发生突变，但是在导出可变引用时及其容易发生突变。虽然在某些特殊情况下，可能需要这样，但是一般情况下只需要导出常量引用。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const foo = 3;\nexport { foo };\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>6 在单个导出的模块中，选择默认模块而不是指定的导出。\n为了鼓励更多的文件只导出一件东西，这样可读性和可维护性更好。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>export default function foo() {}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>7 将所有的 imports 语句放在所有非导入语句的上边。\n由于所有的 imports 都被提前，保持他们在顶部是为了防止意外发生。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>import foo from &#39;foo&#39;;\nimport bar from &#39;bar&#39;;\nfoo.init();\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>8 多行导入应该像多行数组和对象一样缩进。\n花括号和其他规范一样，遵循相同的缩进规则，后边的都好一样。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>import {\n  longNameA,\n  longNameB,\n  longNameC,\n  longNameD,\n  longNameE,\n} from &#39;path&#39;;\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>9 在模块导入语句中禁止使用 Webpack 加载器语法。\n因为在导入语句中使用 webpack 语法，将代码和模块绑定在一起。应该在 webpack.config.js 中使用加载器语法。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>import fooSass from &#39;foo.scss&#39;;\nimport barCss from &#39;bar.css&#39;;\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>##属性</p>\n<p>1 访问属性时使用点符号。\nconst luke = {\njedi: true,\nage: 28,\n};\nconst isJedi = luke.jedi;</p>\n<p>2 使用变量访问属性时，使用 []表示法。\nconst luke = {\njedi: true,\nage: 28,\n};\nfunction getProp(prop) {\nreturn luke[prop];\n}\nconst isJedi = getProp('jedi');</p>\n<p>3 计算指数时，可以使用 ** 运算符。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const binary = 2 ** 10;\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"比较运算符和等号\"><a class=\"header-anchor\" href=\"#比较运算符和等号\" aria-hidden=\"true\">#</a> 比较运算符和等号</h2>\n<p>1 使用 === 和 !== 而不是 == 和 !=。</p>\n<p>2 条件语句，例如 if 语句使用 ToBoolean 的抽象方法来计算表达式的结果，并始终遵循以下简单的规则：\nObjects 的取值为： true\nUndefined 的取值为： false\nNull 的取值为： false\nBooleans 的取值为： 布尔值的取值\nNumbers 的取值为：如果为 +0, -0, or NaN 值为 false 否则为 true\nStrings 的取值为: 如果是一个空字符串 '' 值为 false 否则为 true</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>if ([0] &amp;&amp; []) {\n  // true\n  // 一个数组（既是是空的）是一个对象，对象的取值为 true\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>3 对于布尔值使用简写，但是对于字符串和数字进行显式比较。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>if (isValid) {\n  // ...\n}\nif (collection.length &gt; 0) {\n  // ...\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>4 获取更多信息请查看 Angus Croll 的 Truth Equality and JavaScript 。</p>\n<p>5 在 case 和 default 的子句中，如果存在声明 (例如. let, const, function, 和 class)，使用大括号来创建块 。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>switch (foo) {\n  case 1: {\n    let x = 1;\n    break;\n  }\n  case 2: {\n    const y = 2;\n    break;\n  }\n  case 3: {\n    function f() {\n      // ...\n    }\n    break;\n  }\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>6 三目表达式不应该嵌套，通常是单行表达式。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>// 分离为两个三目表达式\nconst maybeNull = value1 &gt; value2 ? &#39;baz&#39; : null;\n// better\nconst foo = maybe1 &gt; maybe2\n  ? &#39;bar&#39;\n  : maybeNull;\n\n// best\nconst foo = maybe1 &gt; maybe2 ? &#39;bar&#39; : maybeNull;\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>7 避免不必要的三目表达式。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const foo = a || b;\nconst bar = !!c;\nconst baz = !c;\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>8 使用该混合运算符时，使用括号括起来。 唯一例外的是标准算数运算符 (+, -, *, &amp; /) 因为他们的优先级被广泛理解。\n这能提高可读性并且表明开发人员的意图。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const foo = (a &amp;&amp; b &lt; 0) || c &gt; 0 || (d + 1 === 0);\nconst bar = (a ** b) - (5 % d);\nif (a || (b &amp;&amp; c)) {\n  return d;\n}\nconst bar = a + b / c * d;\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"块\"><a class=\"header-anchor\" href=\"#块\" aria-hidden=\"true\">#</a> 块</h2>\n<p>1 当有多行代码块的时候，使用大括号包裹。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>if (test) return false;\nif (test) {\n  return false;\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>2 如果你使用的是 if 和 else 的多行代码块，则将 else 语句放在 if 块闭括号同一行的位置。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>if (test) {\n  thing1();\n  thing2();\n} else {\n  thing3();\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>3 如果一个 if 块总是执行一个 return 语句，那么接下来的 else 块就没有必要了。\n如果一个包含 return 语句的 else if 块，在一个包含了 return 语句的 if 块之后，那么可以拆成多个 if 块。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function cats() {\n  if (x) {\n    return x;\n  }\n  if (y) {\n    return y;\n  }\n}\n\nfunction dogs(x) {\n  if (x) {\n    if (z) {\n      return y;\n    }\n  } else {\n    return z;\n  }\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"eslint\"><a class=\"header-anchor\" href=\"#eslint\" aria-hidden=\"true\">#</a> ESlint</h2>\n<pre><code>```\nmodule.exports = {\n\n  //此项是用来告诉eslint找当前配置文件不能往父级查找\n  root: true,\n\n  //此项是用来指定eslint解析器的，解析器必须符合规则，babel-eslint解析器是对babel解析器的包装使其与ESLint解析\n  parser: 'babel-eslint',\n\n  //此项是用来指定javaScript语言类型和风格，sourceType用来指定js导入的方式，默认是script，此处设置为module，指某块导入方式\n  parserOptions: {\n    // 设置 script(默认) 或 module，如果代码是在ECMASCRIPT中的模块\n    sourceType: 'module',\n    &quot;ecmaVersion&quot;: 6,\n    &quot;ecmaFeatures&quot;: {\n      &quot;jsx&quot;: true\n    }\n  },\n\n  // 此项指定环境的全局变量，下面的配置指定为浏览器环境\n  env: {\n    &quot;browser&quot;: true,\n    &quot;node&quot;: true,\n    &quot;commonjs&quot;: true,\n    &quot;es6&quot;: true,\n    &quot;amd&quot;: true\n  },\n  \n  // 此项是用来配置标准的js风格，就是说写代码的时候要规范的写，如果你使用vs-code我觉得应该可以避免出错\n  extends: 'vue',\n  // 此项是用来提供插件的，插件名称省略了eslint-plugin-，下面这个配置是用来规范html的\n  plugins: [\n    'html',\n    &quot;flow-vars&quot;, \n    &quot;react&quot;\n  ],\n\n  /* \n  下面这些rules是用来设置从插件来的规范代码的规则，使用必须去掉前缀eslint-plugin-\n    主要有如下的设置规则，可以设置字符串也可以设置数字，两者效果一致\n    &quot;off&quot; -&gt; 0 关闭规则\n    &quot;warn&quot; -&gt; 1 开启警告规则\n    &quot;error&quot; -&gt; 2 开启错误规则\n  */\n  rules: {\n    // 警告\n    &quot;no-extra-parens&quot;: 1, // 非必要的括号\n    &quot;no-empty&quot;: 1, // 块语句中的内容不能为空\n    &quot;no-use-before-define&quot;: [1, &quot;nofunc&quot;], // 未定义前不能使用\n    &quot;no-unused-vars&quot;: 1, // 不能有声明后未被使用的变量或参数\n    &quot;no-undef&quot;: 1, // 不可以 有未定义的变量\n    // vue\n    &quot;flow-vars/define-flow-type&quot;: 1,\n    &quot;flow-vars/use-flow-type&quot;: 1,\n\n    // react\n    &quot;react/jsx-uses-react&quot;: 2,\n    &quot;react/jsx-uses-vars&quot;: 2,\n\n    // 代码风格\n    &quot;no-multi-spaces&quot;: 1, // 不能用多余的空格\n    &quot;key-spacing&quot;: [1, {  // 对象字面量中冒号的前后空格\n      &quot;beforeColon&quot;: false,\n      &quot;afterColon&quot;: true\n    }],\n    &quot;block-scoped-var&quot;: 2, // 块语句中使用var\n    &quot;consistent-return&quot;: 2, // return 后面是否允许省略\n    &quot;accessor-pairs&quot;: 2, // 在对象中使用getter/setter\n    &quot;no-return-assign&quot;: [2, &quot;always&quot;], // return 语句中不能有赋值表达式\n    &quot;no-redeclare&quot;: [2, {   // 禁止重复声明变量\n      &quot;builtinGlobals&quot;: true\n    }],\n    &quot;space-infix-ops&quot;: 2, // 中缀操作符周围要不要有空格\n    &quot;curly&quot;: 1, // 必须使用 if(){} 中的{}\n\n    // common js\n    &quot;no-duplicate-imports&quot;: 1\n  }\n}\n```\n</code></pre>\n<h2 id=\"eslint2\"><a class=\"header-anchor\" href=\"#eslint2\" aria-hidden=\"true\">#</a> ESlint2</h2>\n<pre><code>```\n&quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee\n&quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 {a:1,a:1}\n&quot;no-empty&quot;: 2,//块语句中的内容不能为空\n&quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符\n&quot;no-eval&quot;: 1,//禁止使用eval\n&quot;no-extra-parens&quot;: 2,//禁止非必要的括号\n&quot;no-extra-semi&quot;: 2,//禁止多余的冒号\n&quot;no-func-assign&quot;: 2,//禁止重复的函数声明\n&quot;no-inline-comments&quot;: 0,//禁止行内备注\n&quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同\n&quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格\n&quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格\n&quot;no-multi-spaces&quot;: 1,//不能用多余的空格\n&quot;no-multiple-empty-lines&quot;: [1, {&quot;max&quot;: 2}],//空行最多不能超过2行\n&quot;no-redeclare&quot;: 2,//禁止重复声明变量\n&quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式\n&quot;no-self-compare&quot;: 2,//不能比较自身\n&quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2]\n&quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格\n&quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super\n&quot;no-undef&quot;: 1,//不能有未定义的变量\n&quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾\n&quot;no-unused-vars&quot;: [2, {&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;}],//不能有声明后未被使用的变量或参数\n&quot;no-use-before-define&quot;: 2,//未定义前不能使用\n&quot;no-var&quot;: 0,//禁用var，用let和const代替\n\n&quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格\n&quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来\n&quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号\n&quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter\n&quot;camelcase&quot;: 2,//强制驼峰法命名\n&quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名\n&quot;default-case&quot;: 2,//switch语句最后必须有default\n&quot;eqeqeq&quot;: 2,//必须使用全等\n&quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式\n&quot;indent&quot;: [2, 4],//缩进风格\n```</code></pre>\n</div>\n",null]}