{"remainingRequest":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!D:\\1\\实训一\\study\\study\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!D:\\1\\实训一\\study\\study\\lib\\webpack\\markdownLoader.js??ref--1-2!D:\\1\\实训一\\study\\study\\src\\zh\\chain\\Diff DOM.md?vue&type=template&id=3bb69c90&","dependencies":[{"path":"D:\\1\\实训一\\study\\study\\src\\zh\\chain\\Diff DOM.md","mtime":1557283078962},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\1\\实训一\\study\\study\\lib\\webpack\\markdownLoader.js","mtime":1557200316988}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"content\" }, [\n      _c(\"h1\", { attrs: { id: \"diff-dom\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#diff-dom\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Diff DOM\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _c(\"img\", {\n          attrs: {\n            src: \"https://img-blog.csdn.net/20180717182348969\",\n            alt: \"cmd-markdown-Tree DIFF\"\n          }\n        })\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"DIFF算法在执行时有三个维度，分别是Tree DIFF、Component DIFF和Element DIFF，执行时按顺序依次执行，它们的差异仅仅因为DIFF粒度不同、执行先后顺序不同。\\n\"\n        ),\n        _c(\"img\", {\n          attrs: {\n            src: \"https://img-blog.csdn.net/2018071718264787\",\n            alt: \"cmd-markdown-Tree DIFF\"\n          }\n        })\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"Tree DIFF是对树的每一层进行遍历，如果某组件不存在了，则会直接销毁。如图所示，左边是旧属，右边是新属，第一层是R组件，一模一样，不会发生变化；第二层进入Component DIFF，同一类型组件继续比较下去，发现A组件没有，所以直接删掉A、B、C组件；继续第三层，重新创建A、B、C组件。\\n\"\n        ),\n        _c(\"img\", {\n          attrs: {\n            src: \"https://img-blog.csdn.net/20180717182802621\",\n            alt: \"cmd-markdown-Tree DIFF\"\n          }\n        })\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"如图所示，第一层遍历完，进行第二层遍历时，D和G组件是不同类型的组件，不同类型组件直接进行替换，将D删掉，再将G重建。\\n\"\n        ),\n        _c(\"img\", {\n          attrs: {\n            src: \"https://img-blog.csdn.net/20180717182842111\",\n            alt: \"cmd-markdown-Tree DIFF\"\n          }\n        })\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"Element DIFF紧接着以上统一类型组件继续比较下去，常见类型就是列表。同一个列表由旧变新有三种行为，插入、移动和删除，它的比较策略是对于每一个列表指定key，先将所有列表遍历一遍，确定要新增和删除的，再确定需要移动的。如图所示，第一步将D删掉，第二步增加E，再次执行时A和B只需要移动位置即可。\"\n        )\n      ])\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}